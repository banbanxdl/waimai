<?php
namespace app\common\controller;

use app\common\model\AuthGroup;
use think\Controller;
use think\Db;
use think\Request;
use think\Session;
use think\Loader;
use Think\View;
use auth\Auth;

class Core extends Controller
{
    /**
     * @var                        用于树型数组完成递归格式的全局变量
     */
    protected $createTree;

    //url path
    protected $title;

    protected function _initialize()
    {
        $request = Request::instance();
        $controller = $request->controller();
        $value['menu'] = $request->param('menu');
        $value['but_type'] = $request->param('but_type');
        $value['but_site'] = $request->param('but_site');
        $value['but_field'] = $request->param('but_field');
        //去除空值
        $value=array_filter($value);
        $this->title = $request->module().'/'.$controller.'/'.$request->action();
        if (!empty($value)){
            $this->title = $this->title.'$'.http_build_query($value);
        }
        if (!Session::has('name')) {
            $this->error('您还没有登录，或登录已经过期，请重新登录', url('login/index'));
            $this->redirect(url('login/index'));
        }
        if (Session::get('auth_type_id') == 1) {
            $auth = new Auth();
            if ($controller != 'Index') {
                if (!$auth->check('all,' . $this->title, Session::get('id'), 'or')) {
                    $this->error('你没有权限,请联系管理员', url('index/welcome'));
                }
            }
        }elseif (in_array(Session::get('auth_type_id'),[2,3,4,5])) {
            $id = Db::name('auth_rule')->where('name', $this->title)->value('id');
            $arr = AuthGroup::get(['auth_type_id'=>Session::get('auth_type_id')]);
            if (!in_array($id, $arr['rules']) && $controller != 'Index') {
                $this->error('你没有权限,请联系管理员', url('index/welcome'));
            }
        }else{
            $this->error('您还没有登录，请重新登录', url('login/index'));
        }
        parent::_initialize(); // TODO: Change the autogenerated stub
    }

    /**
     *                             将数据集转换成Tree
     * @param $data                内容数组
     * @param int $pid             判断的参数
     * @param string $feild1       字段
     * @param string $filed2       字段
     * @param int $lever           条件次数
     * @param bool $true
     * @return array
     */
    protected function arrayTree($data, $pid=0, $feild1 = 'pid', $filed2 = 'id', $lever = 0, $true = true)
    {
        if ($true == true)
            $this->createTree = array();
        foreach ($data as $key => $v) {
            $prefix = str_repeat('&nbsp;',$lever * 4);
            $prefix .= "|- ";
            $v['level']  = $lever;
            $v['prefix'] = $lever == 0 ? '' : $prefix;
            if ($v[$feild1] == $pid) {
                array_push($this->createTree,$v);
                $this->arrayTree($data, $v[$filed2], $feild1, $filed2,$lever + 1,false);//下一集递归
            }
        }
        return $this->createTree;
    }

    /**
     * two areas
     * distence 距离
     * @param $lat1
     * @param $lng1
     * @param $lat2
     * @param $lng2
     * @return float
     */
    public function getDistance($lat1, $lng1, $lat2, $lng2)
    {
        $earthRadius = 6370856; //approximate radius of earth in meters

        /*
        Convert these degrees to radians
        to work with the formula
        */

        $lat1 = ($lat1 * pi() ) / 180;
        $lng1 = ($lng1 * pi() ) / 180;

        $lat2 = ($lat2 * pi() ) / 180;
        $lng2 = ($lng2 * pi() ) / 180;

        /*
        Using the
        Haversine formula
        http://en.wikipedia.org/wiki/Haversine_formula
        calculate the distance
        */

        $calcLongitude = $lng2 - $lng1;
        $calcLatitude = $lat2 - $lat1;
        $stepOne = pow(sin($calcLatitude / 2), 2) + cos($lat1) * cos($lat2) * pow(sin($calcLongitude / 2), 2);
        $stepTwo = 2 * asin(min(1, sqrt($stepOne)));
        $calculatedDistance = $earthRadius * $stepTwo;

        return round($calculatedDistance);
    }

    /**
     * 合并二维数组的重复数据
     * @param $array2D
     * @return array
     */
    public static function arrtUnique($array2D)
    {
        foreach ($array2D as $v){
            $v=join(',',$v); //降维,也可以用implode,将一维数组转换为用逗号连接的字符串
            $temp[]=$v;
        }
        $temp=array_unique($temp); //去掉重复的字符串,也就是重复的一维数组
        foreach ($temp as $k => $v){
            $temp[$k]=explode(',',$v); //再将拆开的数组重新组装
        }
        return $temp;
    }

    /**
     * 两个数组比较取出相同的键值的值
     * @param $arr_one 取出相同的键值的值 数组
     * @param $arr_two 对比数组
     * @return mixed
     */
    public static function arrayTwoSum($arr_one,$arr_two)
    {
        foreach ($arr_two as $key => $val){
            $time[] = $key;
        }
        foreach ($arr_one as $key => $val){
            if (in_array($key,$time)){
                //$array[$key] = $val;
                $array[] = $val;
            }
        }
        return $array;
    }




}
